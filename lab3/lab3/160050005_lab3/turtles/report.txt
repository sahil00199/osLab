To create the shell I first understood the output of the tokenizer. 
After doing so, the first thing I did was to implement the exit functionality which was done simply by comparing the entire input string "line" with the string "exit". Then, I defined a signal_handler to ensure that control-C does not lead to termination. 
After that I wrote code to execute all functions except cd using the execvp command - which takes as input the main command (token[0]) and an array of arguments or tokens - tokens. In this case, I forked the process and called execvp when I was in the child process.
Once this started working I implemented the case for "cd" which was based on calling the chdir function after checking a few conditions.
Once I checked this, I moved on to implementing multiple commands separated by ';;'. To do this I checked if some token was ';;', extracted the different commands and called a function "executot(char *. char **)" on each command. 
To implement the ">" functionality, I modified the executor function to check if one of the tokens was '>'. In case it was, I found the name of the file to write to and then used dup2 to change the file descriptor. Basically, the role of stdout was now played by a new file descriptor I defined. All this was done in the child function after a call to fork() to ensure that the file descriptor of the parent process remains unchanged.